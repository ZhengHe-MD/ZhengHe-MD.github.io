<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhenghe-md.github.io","root":"/blog/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="郑鹤的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhengHe">
<meta property="og:url" content="https://zhenghe-md.github.io/page/2/index.html">
<meta property="og:site_name" content="ZhengHe">
<meta property="og:description" content="郑鹤的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhengHe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhenghe-md.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>ZhengHe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style><link rel="alternate" href="/blog/atom.xml" title="ZhengHe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhengHe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/2020/02/17/Dapper-a-Large-Scale-Distributed-Systems-Tracing-Infrastructure-2010/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpeg">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/17/Dapper-a-Large-Scale-Distributed-Systems-Tracing-Infrastructure-2010/" class="post-title-link" itemprop="url">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure (2010)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-17 18:16:20" itemprop="dateCreated datePublished" datetime="2020-02-17T18:16:20+00:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-03 12:56:31" itemprop="dateModified" datetime="2020-04-03T12:56:31+00:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/papers-we-love/" itemprop="url" rel="index">
                    <span itemprop="name">papers-we-love</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/17/Dapper-a-Large-Scale-Distributed-Systems-Tracing-Infrastructure-2010/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/17/Dapper-a-Large-Scale-Distributed-Systems-Tracing-Infrastructure-2010/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>早在 2008 年，Google 就已开始分布式调用链追踪的工作，经过两年的打磨后，Dapper 系统问世，并通过这篇文章将其设计公之于众。遗憾的是，Dapper 并不是开源项目，但它的设计理念依然深刻影响到后来的 Jaeger、Zipkin 等开源分布式追踪项目，以及相关的标准 Opentracing、OpenTelemetry。</p>
<p>本文不是原文的精准翻译，而是一次重述和简述，旨在记录分布式调用链追踪要解决的核心问题和潜在解决方案。</p>
<h1 id="why-design-goals">Why &amp; Design Goals</h1>
<p>云原生环境中，一次请求的处理可能途径多个服务的任意实例，彻底理解系统就需要理解各服务内部的逻辑，理清这些服务之间的关系，甚至有时候还需要了解服务所在物理机的当时状态。系统出现异常时，如果其行为无法被追踪、被理解，就无法为解决异常快速提供线索。</p>
<p>通常这些异常会被监控捕捉，如时延异常、错误日志、程序崩溃，在紧急处理之后，就需要调查案发现场，彻底解决问题。这时候就需要了解每个请求在整个微服务集群内部的行踪。</p>
<p>这就向分布式追踪系统提出了两点要求：</p>
<ul>
<li>处处部署 (ubiquitous deployment)</li>
<li>持续监控 (continuous monitoring)</li>
</ul>
<p>如果部署不完全或者监控有间断，就可能有一小部分历史无法被追踪到，从而影响到问题定位的准确度，使得追踪效果大打折扣。</p>
<p>据此，我们提出追踪系统的 3 个主要设计目标：</p>
<ol type="1">
<li><strong>低成本 (Low overhead)</strong>：对服务的性能影响应该能够忽略不计</li>
<li><strong>对应用透明 (Application-level transparency)</strong>：应用开发者对追踪系统无感知</li>
<li><strong>扩展性好 (Scalability)</strong>：支持部署到所有服务的所有实例上</li>
</ol>
<p>在此基础上，数据从采集到可以被查询、分析的延迟越小越好，起到的作用也越大、越及时。</p>
<h1 id="how">How</h1>
<h2 id="general-approaches">General Approaches</h2>
<p>分布式追踪的设计方案主要可以分为两类：黑盒法（black-box）和标记法（annotation-based）：</p>
<h3 id="黑盒法">黑盒法</h3>
<p>黑盒法无需任何侵入性代码，只通过统计回归等手段来推测服务之间的关系。它的优势在于无需修改代码，缺点在于记录不准确，且需要大量数据才能够推导出服务间的关系。</p>
<h3 id="标记法">标记法</h3>
<p>标记法需要为每个请求打标记，并通过一个全局标识符将请求途径的所有服务信息串联，复盘整个链路。标记法记录准确，但它的缺点也很明显，需要将标记代码注入到每个服务中。</p>
<p>在 Google 内部，几乎所有应用都使用相同的 threading model、control flow 和 RPC systems，因此可以将打标记的工作集中在少量的公共库中，同样能够达到对应用透明的效果。</p>
<h2 id="data-models">Data Models</h2>
<p>通常一个请求在微服务集群中的调用链可以被抽象成树形结构，假设 RequestX 的处理过程如下图所示:：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LzZkDzl5FDpMB3N6FWj%2F-LzZohKpQwwXEAggeNnR%2FScreen%20Shot%202020-01-27%20at%2010.26.45%20AM.jpg?alt=media&amp;token=4abea3f6-a071-4078-8c2a-8d176fa17f35" style="zoom:40%;" /></p>
<p>相应调用链追踪的树状结构为：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LzZkDzl5FDpMB3N6FWj%2F-LzZpKdJRxQj9jYRwE2p%2FScreen%20Shot%202020-01-27%20at%2010.26.31%20AM.jpg?alt=media&amp;token=3fd0ff8b-3a5a-4f94-a53b-82b2c789e9f0" style="zoom:50%;" /></p>
<p>整棵树称为一个 trace，树上的节点称为 span。每个 span 都记录着 parent id 和 trace id，表明其所属父节点和调用链，其中没有 parent id 的 span 称为 root span，root span 的 id 就是 trace id。</p>
<p>每个 span 都需要记录其开始时间和结束时间，如果应用开发者有记录其它信息的需求，则可以手动增加相应的标记。</p>
<h2 id="pipeline">Pipeline</h2>
<p>Dapper 记录、收集调用链信息的流水线主要分成 3 个阶段：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LzZuNs2PN7fitdgKdSX%2F-LzZw7CCiTRmnBESMsKE%2FScreen%20Shot%202020-01-27%20at%2010.59.13%20AM.jpg?alt=media&amp;token=1251874d-8189-4591-b246-84cc36a4da34" style="zoom:67%;" /></p>
<ol type="1">
<li>span 数据写入本地日志文件</li>
<li>dapper daemon 从本地日志文件中收集数据</li>
<li>dapper collectors 将数据写入 Bigtable 的大区仓库 (regional repositories)</li>
</ol>
<p>在 Bigtable 中，每行数据就是一个 trace，且每行可以有任意列，恰好方便存储不定长的 trace/span 数据。Dapper 向开发者提供相应的 API 和 SDK，方便 Google 的开发者能够据此搭建数据分析工具，定制化地辅助线上问题排查。</p>
<h2 id="overhead">Overhead</h2>
<p>调用链追踪的主要成本在于：trace generation 和 collection。</p>
<h3 id="trace-generation">Trace generation</h3>
<p>在 Dapper 中，生成 root span 需要 204 ns，生成 non-root span 需要 176 ns。这里面相差的部分就是生成 全局唯一 trace id 的时间成本。</p>
<p>在 Dapper 的 runtime library 中，最耗时的操作就是将 trace 信息写入本地磁盘，但考虑到使用批量和异步写入的方式优化，对被跟踪的服务本身的影响就相对削弱了。</p>
<h3 id="trace-collection">Trace collection</h3>
<p>Dapper daemon 需要从本地日志文件中读取 trace 信息，然后发送给 Dapper collectors。经过 benchmark 测试验证，Dapper daemon 从未使用超过单核 0.3% 的计算资源，且使用的内存空间极小，可忽略不计。同时 Dapper daemon 在 kernel scheduler 中的优先级被设置为最低，必要时会出让计算资源。</p>
<p>在实践中，平均每个 span 的大小约为 426 字节，经过计算，在生产环境中 Dapper 占用的网络带宽大约为总量的 0.01%。</p>
<h3 id="effect-on-production-workloads">Effect on production workloads</h3>
<p>高吞吐的服务随时都会接收大量的请求，产生大量的 tracing 数据，而这类服务通常又是对性能最敏感的。下表中以 Google 的网页搜索服务集群为例，测量了不同的 trace 采样率对服务本身的影响：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-LzzYHlM85L3z5GmLl19%2F-Lzzi5vkmme-1FkOdHC7%2FScreen%20Shot%202020-02-01%20at%203.47.42%20PM.jpg?alt=media&amp;token=3d561901-dede-4f09-b268-87bec6607b54" style="zoom:50%;" /></p>
<p>The experimental errors for these latency and throughput measurements are 2.5% and 0.15% respectively.</p>
<p>从图中可以发现，尽管调用链追踪带来的性能影响不是很大，但并不能忽略不计，对 trace 数据进行抽样是很有必要的。当抽样率小于 1/16 时，影响范围已经小于误差范围。在实践中，我们设置 1/1024 的抽样率就能收集到足够多的 trace 数据。</p>
<p>除此之外，使用更低的采样率可以让 trace 数据在本地磁盘存活更长的时间，为整个搜集框架争取更大的灵活度。</p>
<h3 id="adaptive-sampling">Adaptive Sampling</h3>
<p>调用链追踪的成本与单位时间内收集的 trace 数量成正比。在 Dapper 的首个生产版本中，采用了统一的采样率 1/1024，这种固定采样率不会对高吞吐的在线服务产生不必要的影响。但在这样的采样率下，可能忽略掉一些发生不频繁的重要事件。</p>
<p>因此 Dapper 团队正在研发自适应采样率机制，针对不频繁的重要事件能提高采样率。实际被使用的抽样率会被记录在 trace/span 数据中，帮助后期工具分析。</p>
<h3 id="additional-sampling">Additional Sampling</h3>
<p>上面介绍的均匀抽样和自适应抽样都是为了减少对被追踪服务本身性能的影响。但 Dapper 本身还需要控制整体抽样数据的规模，在论文发表时，Dapper 在生产环境中每天将产生 1T 的追踪数据；同时 Dapper 的用户希望追踪数据能够保持两周。因此这里存在着存储资源与追踪密度之间的权衡。除此之外，高抽样率也会提升 Dapper collectors、Bigtable 的吞吐量。因此 Dapper 团队引入了额外的一层抽样，来实现全局的、系统级的控制。</p>
<p>实现的思路很简单，将每个 trace id 哈希到 [0, 1]，如果哈希值小于给定的抽样系数，则通过；大于则拦截。在实践中，额外的抽样给与 Dapper 团队更强的全局控制力。</p>
<h1 id="where">Where</h1>
<h2 id="general-purpose-tools">General-Purpose Tools</h2>
<h3 id="dapper-depot-api">Dapper Depot API</h3>
<p>Dapper 向开发者开放一系列 API：</p>
<ul>
<li>Access by trace id</li>
<li>Bulk access</li>
<li>Indexed access</li>
</ul>
<p>在实践中，Dapper 发现 (service_name, host_machine, timestamp) 的联合索引恰好能满足大部分开发者的需求。</p>
<h3 id="dapper-user-interface">Dapper user interface</h3>
<p>dapper user interface 可以理解为 APM 系统，方便开发者快速对线上问题做根源分析。交互界面和 user story 详见论文。</p>
<h2 id="experiences">Experiences</h2>
<h3 id="using-dapper-during-development">Using Dapper during development</h3>
<p>Dapper 主要在以下几个方面帮助开发者改进服务：</p>
<ul>
<li>Performance：通过调用链示意图发现服务瓶颈</li>
<li>Correctness：dapper 通过标签帮助开发者发现一些本该访问 master 节点的请求访问了 replicas</li>
<li>Understanding：dapper 帮助开发者理解自身系统的依赖，增进对复杂系统的理解，为架构层面优化提供依据</li>
<li>Testing：开发者可以通过观察调用链信息测试系统的行为是否符合预期</li>
</ul>
<h3 id="addressing-long-tail-latency">Addressing long tail latency</h3>
<p>Google 内部的一位工程师利用 Dapper 提供的接口来推断服务的关键路径，进而减少服务整体时延。</p>
<h3 id="inferring-service-dependencies">Inferring service dependencies</h3>
<p>服务之间的依赖关系常常是动态变化的，我们基本无法通过扫描配置信息、代码来确定服务之间的依赖关系。 Google 的 "Service Dependencies" 项目正是利用 Dapper 的近期数据来推断依赖关系。</p>
<h3 id="network-usage-of-different-services">Network usage of different services</h3>
<p>在发现网络带宽使用异常时，Dapper 可以辅助开发者锁定到具体的请求。</p>
<h3 id="layered-and-shared-storage-systems">Layered and Shared Storage Systems</h3>
<p>一些公共服务通常很难知道其调用方及各自调用量，Dapper 帮助这些公共服务的维护者更好地了解它们。</p>
<h1 id="references">References</h1>
<p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf" target="_blank" rel="noopener">Dapper</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhenghe-md.github.io/2020/02/16/Gorilla-A-Fast-Scalable-In-Memory-Time-Series-Database-2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpeg">
      <meta itemprop="name" content="ZhengHe">
      <meta itemprop="description" content="郑鹤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhengHe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/16/Gorilla-A-Fast-Scalable-In-Memory-Time-Series-Database-2015/" class="post-title-link" itemprop="url">Gorilla: A Fast, Scalable, In-Memory Time Series Database (2015)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-16 22:46:29" itemprop="dateCreated datePublished" datetime="2020-02-16T22:46:29+00:00">2020-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-03 12:56:31" itemprop="dateModified" datetime="2020-04-03T12:56:31+00:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/papers-we-love/" itemprop="url" rel="index">
                    <span itemprop="name">papers-we-love</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/16/Gorilla-A-Fast-Scalable-In-Memory-Time-Series-Database-2015/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/16/Gorilla-A-Fast-Scalable-In-Memory-Time-Series-Database-2015/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="abstract">Abstract</h1>
<p>在大型微服务架构中，服务监控和实时分析需要大量的时序数据。存储这些时序数据最高效的方案就是使用时序数据库 (TSDB)。设计时序数据库的重要挑战之一便是在效率、扩展性和可靠性中找到平衡。这篇论文介绍的是 Facebook 内部孵化的内存时序数据库，Gorilla。Facebook 团队发现：</p>
<ol type="1">
<li>监控系统的用户主要关注的是数据的聚合分析，而不是单个数据点</li>
<li>对于线上问题的根源分析来说，最近的数据比过去的数据更有价值</li>
</ol>
<p>Gorilla 以可能抛弃少量数据为代价，在读写高可用方面做了优化。为了改进查询效率，开发团队使用了激进的压缩技术：</p>
<ol type="1">
<li>delta-of-delta timestamps</li>
<li>XOR's floating point values</li>
</ol>
<p>相比基于 HBase 的方案，Gorilla 将内存消耗缩小 10 倍，并使得数据得以存放在内存中，进而将查询时延减少 73 倍，查询吞吐量提高了 14 倍。 这样的性能改进也解锁了更多的监控、调试工具，如相关性分析、密集可视化。Gorilla 甚至能够优雅的解决单点到整个可用区域故障的问题。</p>
<h1 id="introduction">Introduction</h1>
<p>以下是 FB 内部对时序数据库的要求：</p>
<h2 id="write-dominate">Write Dominate</h2>
<p>对时序数据库的首要限制就是必须一直能够写入数据，即写数据的高可用。因为 FB 内部的服务集群每秒将产生 1 千万个采样数据点。相较之下，读数据比写数据要求通常要低好几个数量级，因为数据的消费者是一些运维、开发使用的控制面板以及自动化报警系统，它们的请求频率低且通常只关注部分时序数据。由于用户关注的往往是整组时序数据的聚合结果，而不是单个数据点，因此传统数据库中的 ACID 保证也并不是时序数据库的核心要求，即便在极端情况下，丢弃少量数据也不会影响核心用途。</p>
<h2 id="state-transition">State Transition</h2>
<p>FB 内部希望能够及时发现一些系统的状态转移事件，如：</p>
<ul>
<li>服务新版本发布</li>
<li>服务配置修改</li>
<li>网络切换</li>
<li>...</li>
</ul>
<p>因此要求时序数据库能支持对较短的时间窗口内的采样数据进行细粒度的聚合。具备在十秒级内展示捕获到的状态转移事件能够帮助自动化工具快速发现问题，阻止其发生扩散。</p>
<h2 id="high-availability">High Availability</h2>
<p>即便当不同 DC 之间发生网络分区，DC 内部的服务也应当能够将实时监控的数据写入到 DC 内部的时序数据库，也能够从中读取数据。</p>
<h2 id="fault-tolerance">Fault Tolerance</h2>
<p>如果能够将数据复制到多个区域 (regions)，就可以在单个 DC 或整个地理区域发生问题时也能正常运作。</p>
<p>Gorilla 正是为满足以上所有要求而开发的时序数据库，它可以被理解成是时序数据的 write-through cache，由于数据都在内存中，Gorilla 几乎可以在 10 毫秒级别内处理大部分请求。通过对 FB 内部已经投入使用很长时间的 Operational Data Store (ODS，基于 HBase 的时序数据库解决方案）的研究，发现超过 85% 的数据查询只涉及到过去 26 小时内产生的数据，通过进一步的调研发现，如果使用内存数据库来代替磁盘（disk-based）数据库，就能够达到用户对响应时间的要求。</p>
<p>在 2015 年春，FB 内部的监控系统共产生超过 20 亿组时间序列，每秒产生 1200 万个，每天 1 万亿个数据点。假设每个采样点需要 16 字节来存储，就意味着一天需要 16 TB 内存。Gorilla 团队通过基于 XOR 的浮点数压缩算法将每个采样点所需字节数降到 1.37，将内存总需求量缩小将近 12 倍。</p>
<p>针对可用性要求，Gorilla 团队在不同区域、DC 中部署多个 Gorilla 实例，实例时间相互同步数据，但不保证一致性。数据的读取请求将被转发到最近的 Gorilla 实例。</p>
<h1 id="background-requirements">Background &amp; Requirements</h1>
<h2 id="ods">ODS</h2>
<p>ODS 是 FB 线上服务监控系统的重要组成部分，它由一个基于 HBash 的时序数据库，数据查询服务以及报警系统共同构成。它的整体架构如下图所示：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M-oozqikIKVYHIizAcT%2F-M-opzgxW6tsJ3uIGn49%2FScreen%20Shot%202020-02-11%20at%2011.22.00%20PM.jpg?alt=media&amp;token=9d1168f7-5c9d-4ea5-8c10-cb7907af4ee3" style="zoom:35%;"></p>
<p>ODS 的消费者主要由两部分构成：</p>
<ol type="1">
<li>便于开发人员分析问题的可交互图表系统</li>
<li>自动化报警系统</li>
</ol>
<p>在 2013 年初，FB 的监控团队意识到基于 HBase 的时序数据库无法处理未来的读负载，尽管图标分析时数据查询的延迟还可以容忍，但达到几秒钟的查询 90th 分位点已经阻塞了自动化报警的正常运作。在眼下其它现成方案都无法满足要求的情况下，监控团队开始将关注点转向缓存解决方案。尽管 ODS 就使用了简单的 read-through cache，但这种方案只是缓存多张图表中共同的时序数据，但每当图表查询最新的数据时，依然还会出现 cache miss，这时候数据读取就击穿到了 HBase。监控团队也考虑过使用 Memcache 作为 write-through cache，但每次写入大量最新数据会对 memcache 引入很大的流量，最终这个方案也被否决了。监控团队需要更加高效的解决方案。</p>
<h2 id="gorilla-requirements">Gorilla Requirements</h2>
<p>以下是对新的解决方案的要求陈述：</p>
<ul>
<li>20 亿组不同的时序数据，每组时序数据用一个唯一的字符串标识</li>
<li>每分钟 7 亿个数据采样点</li>
<li>保存 26 小时的全量数据</li>
<li>数据读取在 1ms 内完成</li>
<li>支持最小采样间隔为 15s</li>
<li>两个复制节点来支持容错，即使有一个节点挂掉也能够继续处理读请求</li>
<li>能够快速扫描所有内存数据</li>
<li>支持每年 2 倍的增长</li>
</ul>
<h1 id="comparison-with-tsdb-systems">Comparison With TSDB Systems</h1>
<p>由于 Gorilla 的设计是将所有数据放在内存中，因此它的内存数据结构与其它的时序数据库有所不同。也得益于这样的设计，开发者也可以将 Gorilla 看作是基于磁盘的时序数据库的 write-through cache。</p>
<h2 id="opentsdb">OpenTSDB</h2>
<p>OpenTSDB 是继续 HBase 的时序数据库解决方案，它与 ODS 的 HBase 存储层很相似。两个系统的表结构设计非常相似，也采用了类似的优化、横向扩容的解决方案。但前面也提到，基于磁盘的解决方案很难支持快速查询的需求。</p>
<p>ODS 的 HBase 存储层会刻意降低旧数据的采样精度，从而节省总体空间占用；OpenTSDB 则会保存数据的完全精度。牺牲旧数据的精度，能够带来更快的旧数据查询速度以及空间的节省，FB 团队认为这是值得的。</p>
<p>OpenTSDB 标识时序数据的数据模型相比 Gorilla 更加丰富，每组时序数据可以标记任意组键值数据，即所谓的标签 (tags)。Gorilla 只通过一个字符串来标记时序数据，它依赖于上层工中从去抽取标识时序数据的信息。</p>
<h2 id="whisper-graphite">Whisper (Graphite)</h2>
<p>Graphite 以 Whisper format 将时序数据存储在本地磁盘上。Whisper format 期望时序数据的采样区间是稳定的，如果采样区间发生抖动，Graphite 就无能为力了。相较之下，如果时序数据的采样区间是稳定的，Gorilla 能够更高效地存储数据，Gorilla 也能处理区间不稳定的情况。在 Graphite 中，每组时序数据都存在一个独立的文件中，新的样本点会覆盖超过一定时间的旧数据；Gorilla 也很类似，但区别在于它将数据存储在内存中。由于 Graphite 是基于磁盘的时序数据库，同样不满足 FB 内部的需求。</p>
<h2 id="influxdb">InfluxDB</h2>
<p>InfluxDB 的数据模型表达力比 OpenTSDB 更加丰富，时序中的每一个样本都可以拥有完整元数据，但这种做法也导致它的数据存储需要占用更多的磁盘空间。InfluxDB 也支持集群部署，横向扩容，运维团队无需管理 HBase/Hadoop 集群。在 FB 中已经有专门的团队负责运维 HBase 集群，因此对于 ODS 团队来说这并不是一个痛点。与其它系统类似，InfluxDB 也将数据存储在磁盘中，其查询效率要远低于内存数据库。</p>
<h1 id="gorilla-architecture">Gorilla Architecture</h1>
<p>在 Gorilla 中，每条时序样本数据都由一个三元组构成：</p>
<ul>
<li>string key：用于标识所属的时序</li>
<li>timestamp (int64)：时间戳</li>
<li>value (float64)：样本值</li>
</ul>
<p>Gorilla 采用一种新的时序压缩算法，将存储每条时序样本数据所需的空间由之前的 16 字节降到了平均 1.37 个字节。</p>
<p>通过将每组时序数据通过 string key 分片到某个的 Gorilla 服务，就能比较容易地实现横向扩容。在 Gorilla 正式上线 18 个月后，存储 26 小时的数据约需要 1.3TB 内存，每个集群需要 20 台机器。在论文写作时，每个集群已经需要 80 台机器。</p>
<p>Gorilla 通过同时将时序数据写入两台位于不同 regions 的机器中，来抵御单点故障、网络分区、甚至整个 DC 故障。一旦发现故障，所有的读请求将被转发到备选 region 中的服务上，保证用户对故障无明显感知。</p>
<h2 id="time-series-compression">Time Series Compression</h2>
<p>Gorilla 对压缩算法主要有两个要求：</p>
<ul>
<li>流式压缩：无需读取完整数据</li>
<li>无损压缩：不能损失数据精度</li>
</ul>
<p>对比连续的样本数据分析，能够观察到：</p>
<ul>
<li>连续的时间戳之间间隔通常为常数，如 15 秒</li>
<li>连续的数据值之间的二进制编码差别较小</li>
</ul>
<p>因此 Gorilla 对时间戳和数据值分别使用不同的压缩算法。在分析具体算法之前，可以看一下算法的整体流程：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M076DRX3KJNR7GR47Aj%2F-M07DY-do-Yx92_9599M%2FScreen%20Shot%202020-02-15%20at%205.41.51%20PM.jpg?alt=media&amp;token=1779e626-cf8b-43ed-ba35-a443b1758d12" style="zoom:70%;"></p>
<ol type="1">
<li>每块数据的开头记录起始时间戳</li>
<li>第一条样本数据
<ul>
<li>时间戳存储与起始时间戳的差值</li>
<li>数据值按原值存储</li>
</ul></li>
<li>从第二条样本数据开始
<ul>
<li>时间戳存储 delta of delta</li>
<li>数据值按差值存储</li>
</ul></li>
</ol>
<h3 id="compressing-time-stamps">Compressing Time Stamps</h3>
<p>通过分析 ODS 中的时序数据，Gorilla 团队观察到大多数时序样本都是按固定区间到达服务，如 60 秒。尽管偶尔会出现 1 秒钟的延迟或提早，总体上时间窗口是稳定的。</p>
<p>假设连续时间戳的 delta 为：60, 60, 59, 61，那么 delta of delta 就是：0, -1, 2，于是通过起始时间、第一条数据与起始时间的 delta，以及剩下所有样本点的 delta of delta，就能够存储完整的数据。</p>
<p>完整的算法流程如下：</p>
<ol type="1">
<li>在每块数据的 header 中记录起始时间 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex" xmlns="http://www.w3.org/2000/svg" width="2.974ex" height="1.887ex" role="img" focusable="false" viewBox="0 -626 1314.7 834" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" transform="translate(361, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(778, 0)"><use xlink:href="#MJX-TEX-N-31"></use></g></g></g></g></g></svg></mjx-container></span> ，通常按照 2 小时对齐，如 02:00:00、04:00:00。用 14 bits 存储第一个时间戳 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="1.73ex" height="1.791ex" role="img" focusable="false" viewBox="0 -626 764.6 791.6" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" transform="translate(361, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-TEX-N-30"></use></g></g></g></g></g></svg></mjx-container></span> 与 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex" xmlns="http://www.w3.org/2000/svg" width="2.974ex" height="1.887ex" role="img" focusable="false" viewBox="0 -626 1314.7 834" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" transform="translate(361, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(778, 0)"><use xlink:href="#MJX-TEX-N-31"></use></g></g></g></g></g></svg></mjx-container></span> 间的 delta</li>
<li>从第二个时间戳开始：
<ol type="1">
<li>计算 delta of delta： <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="32.537ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14381.5 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-44"></use></g><g data-mml-node="mo" transform="translate(1105.8, 0)"><use xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(2161.6, 0)"><use xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(2550.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" transform="translate(361, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-6E"></use></g></g></g><g data-mml-node="mo" transform="translate(3608, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(4608.3, 0)"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4969.3, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-6E"></use></g><g data-mml-node="mo" transform="translate(822.2, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1822.4, 0)"><use xlink:href="#MJX-TEX-N-31"></use></g></g><g data-mml-node="mo" transform="translate(7291.7, 0)"><use xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7902.9, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mo" transform="translate(8903.2, 0)"><use xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(9292.2, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" transform="translate(361, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-6E"></use></g><g data-mml-node="mo" transform="translate(600, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1378, 0)"><use xlink:href="#MJX-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(11253.3, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(12253.5, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-74"></use></g><g data-mml-node="TeXAtom" transform="translate(361, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-6E"></use></g><g data-mml-node="mo" transform="translate(600, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1378, 0)"><use xlink:href="#MJX-TEX-N-32"></use></g></g></g><g data-mml-node="mo" transform="translate(13992.5, 0)"><use xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg></mjx-container></span></li>
<li>如果 D 为 0，则存储 1 bit，'0'</li>
<li>如果 D 在 [-63, 64] 之间，先存储 2 bits，'10'；然后用 7 bits 存值</li>
<li>如果 D 在 [-255,256] 之间，先存储 3 bits，'110'；然后用 9 bits 存值</li>
<li>如果 D 在 [-2047,2048] 之间，先存储 4 bits，'1110'；然后用 12 bits 存值</li>
<li>如果超出以上区间，先存储 4 bits，'1111'；然后用 32 bits 存值</li>
</ol></li>
</ol>
<p>算法中为 D 选择的区间在真实数据能够获得最大的压缩率。一个时序数据可能随时出现数据点丢失，于是可能出现这样的 delta 序列：60, 60, 121, 59，这时候 delta of delta 就是：0, 61, -62，这时候就需要存储 10 bits 数据。</p>
<p>下图是时序压缩的统计表现：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M07Gf2qkHgCGczoDFhC%2F-M07Jvuu5bTaFdwnufQI%2FScreen%20Shot%202020-02-15%20at%206.09.59%20PM.jpg?alt=media&amp;token=1a8cdc06-9295-404d-9e3e-53634e18561e"></p>
<h3 id="compressing-values">Compressing Values</h3>
<p>通过分析 ODS 的数据，Gorilla 团队观察到大部分相邻的时序数据值之间不会有很大的变化。根据 IEEE 754 中定义的浮点数编码格式：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M07K1suKwPULdOMb_9q%2F-M07OPpSrop1r-jwCl_Z%2FScreen%20Shot%202020-02-15%20at%206.29.27%20PM.jpg?alt=media&amp;token=cd7b35f6-81bf-4b85-8a84-29327f0045b6"></p>
<p>通常相邻的数值之间，sign、exponent 以及 mantissa 前面的一些 bits 不会改变，如下图所示：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M07PpEaRw_f_QmKV5ux%2F-M07UEPzr6ZEJVuKOjle%2FScreen%20Shot%202020-02-15%20at%206.54.50%20PM.jpg?alt=media&amp;token=699c9fbb-f33c-4bf1-a539-d6872b10c63d" style="zoom:80%;"></p>
<p>因此利用这个，我们可以通过记录相邻数值的 XOR 中不同的信息来压缩数据。完整的算法流程如下：</p>
<ol type="1">
<li>第一个数值无压缩存储</li>
<li>如果与上一个数值 XOR 的结果为 0，即数值未发生改变，则存储 1 bit，'0'</li>
<li>如果与上一个数值 XOR 的结果不为 0，则先存储 1 bit，'1'
<ul>
<li>(Control bit '0')：如果当前 XOR 的区间在前一个 XOR 区间里面，那么可以复用前一个 XOR 区间的位置信息，只存储区间内部的 XOR 的值</li>
<li>(Control bit '1')：如果当前 XOR 的区间不在前一个 XOR 区间里面，则先利用 5 bits 存储前缀 0 的数量，再利用 6 bits 存储区间的长度，最后存储区间内部 XOR 的值</li>
</ul></li>
</ol>
<p>具体可参考流程图中的例子，即：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M07PpEaRw_f_QmKV5ux%2F-M07SzVLLTYUfENBeMgn%2FScreen%20Shot%202020-02-15%20at%206.49.34%20PM.jpg?alt=media&amp;token=4a897e4b-bb92-4e29-ac8e-06adc38bdc49" style="zoom:80%;"></p>
<p>下图展示时序数据值压缩算法的统计表现：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M07Gf2qkHgCGczoDFhC%2F-M07Jvuu5bTaFdwnufQI%2FScreen%20Shot%202020-02-15%20at%206.09.59%20PM.jpg?alt=media&amp;token=1a8cdc06-9295-404d-9e3e-53634e18561e" style="zoom:80%;"></p>
<ol type="1">
<li>59% 的数值只需要 1 bit 即可以存储</li>
<li>28% 的数值只需要 26.6 bits 即可存储</li>
<li>13% 的数值需要 39.6 bits 可以存储</li>
</ol>
<p>这里有一个 trade-off 需要考虑：每个数据块所覆盖的时间跨度。更大的时间跨度可以获得更高的压缩率，然而解压缩所需的资源也越多，具体的统计结果展示如下：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M07PpEaRw_f_QmKV5ux%2F-M07UnFE4ykeRj5apM34%2FScreen%20Shot%202020-02-15%20at%206.57.28%20PM.jpg?alt=media&amp;token=22df1ad9-4bab-4ae0-921d-62fc836d838f" style="zoom:67%;"></p>
<p>从图中可以看出在 2 小时之后，继续增大跨度带来压缩率提升的边际收益已经非常小，因此 Gorilla 最终选择 2 小时的时间跨度。</p>
<h2 id="in-memory-data-structures">In-memory Data Structures</h2>
<p>Gorilla 在内存中的数据结构如下图所示：</p>
<p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M088TZ5RDvbNwk1f26D%2F-M08GttrMETZGyjoUwc-%2FScreen%20Shot%202020-02-15%20at%2010.36.24%20PM.jpg?alt=media&amp;token=412fc01f-b75b-4b87-8f12-62711629ef83" style="zoom:67%;"></p>
<p>整个数据结构可以分三层：</p>
<ol type="1">
<li>ShardMap</li>
<li>TSmap</li>
<li>TS</li>
</ol>
<h3 id="shardmap">ShardMap</h3>
<p>每个 Gorilla 节点上都维护着一个 ShardMap，后者负责将时序名称的哈希值映射到相应的 TSmap 上。如果 ShardMap 上对应的指针为空，则目标时序数据不在当前的节点 (分片) 上。由于系统中分片的数量是常数，且预期数量级在 3 位数内，因此存储 ShardMap 的成本很低。ShardMap 的并发访问通过一个 read-write spin lock 来控制。</p>
<h3 id="tsmap">TSmap</h3>
<p>TSmap 是时序数据的索引。它由以下两部分构成：</p>
<ol type="1">
<li>所有 TS 的指针构成的向量，标记为 vector</li>
<li>将时序名称的哈希值映射到 TS 指针的字典，标记为 map</li>
</ol>
<p>vector 用于快速扫描所有数据；map 用于满足稳定、快速的查询请求。TSmap 的并发控制通过一个 read-write spin lock 实现。扫描完整数据时，只需要复制 vector，后者是由一批指针构成，速度很快，critical section 很小；删除数据时，通过 tombstoned 标记删除，被动回收。</p>
<h3 id="ts">TS</h3>
<p>每组时序数据都由一系列数据块构成，每个数据块保存 2 小时的数据，最新的数据块还处于打开状态，上面维持着最近的数据。最新的数据块中只能往后追加数据，一旦时间满 2 小时，数据块就会被关闭，已经关闭的数据块在被清出内存之前不允许再被修改。</p>
<p>读取数据时，查询所涉及的所有数据块将被复制一份，直接返回给 RPC 客户端，数据的解压缩过程由客户端完成。</p>
<h2 id="on-disk-structures">On Disk Structures</h2>
<p>Gorilla 的设计目标之一就是能抵御单点故障，因此 Gorilla 同样需要通过持久化存储做故障恢复。Gorilla 选择的持久化存储是 GlusterFS，后者是兼容 POSIX 标准的分布式文件系统，默认 3 备份。其它分布式文件系统，如 HDFS 也可以使用。Gorilla 团队也考虑使用单机 MySQL 或者 RocksDB，但最终没有选择，原因是 Gorilla 并不需要使用查询语言支持。</p>
<p>一个 Gorilla 节点会维持多个分片的数据，于是它会为每个分片建立一个文件夹。每个文件夹中包含四类文件：</p>
<ol type="1">
<li>Key Lists</li>
<li>Append-only Logs</li>
<li>Complete Block Files</li>
<li>Checkpoint Files</li>
</ol>
<h3 id="key-lists">Key Lists</h3>
<p>Key Lists 实际上就是时序名称到 integer identifier 的映射，后者是时序在 TSmap vector 中的偏移值。Gorilla 会周期性地更新 Key Lists 数据。</p>
<h3 id="append-only-logs">Append-only Logs</h3>
<p>当所有时序数据的样本点流向 Gorilla 节点时，Gorilla 会将他们压缩后的数据交织地写入日志文件中。但这里的日志文件并不是 WAL，Gorilla 也并没有打算提供 ACID 支持，当日志数据在内存中满 64 KB 后会被追加到 GlusterFS 中相应的日志文件中。故障发生时，将有可能出现少量数据丢失，但为了提高写吞吐，这个牺牲还算值得。</p>
<h3 id="complete-block-files">Complete Block Files</h3>
<p>每隔 2 小时，Gorilla 会将数据块压缩后复制到 GlusterFS 中。每当一块数据持久化完成后，Gorilla 就会创建一个 checkpoint 文件，同时删除相应的日志文件。checkpoint 文件被用来标识数据块持久化成功与否。故障恢复时，Gorilla 会通过 checkpoint 和日志文件载入之前的数据。</p>
<h2 id="handling-failures">Handling Failures</h2>
<p>在容错方面，Gorilla 优先支持以下场景：</p>
<ul>
<li>单点故障，如果是临时故障则客户端完全无感知，常用于新版发布</li>
<li>大范围、区域性故障：如 region 范围的网络分区</li>
</ul>
<h3 id="high-availability-1">High Availability</h3>
<p>Gorilla 通过在两个不同区域的 DC 维护两台独立的实例保障服务的可用性。同一组时序数据写入时，会被发送给这两台独立的实例上，但不保证两次写操作的原子性。当一个区域故障时，读请求将被尝试发送到另一个区域。如果该区域的故障持续超过 1 分钟，读请求将不再发送给它，直到该区域中的实例数据已经正常写入 26 小时为止。</p>
<p>在每个区域内部，一种基于 Paxos 的 ShardManager 用于维护分片与节点之间的关系。当一个节点发生故障时，ShardManager 会将它维护的分片重新分配给集群内部的其它节点。分片转移通常能够在 30 秒内完成，在分片转移的过程中，写入数据的客户端将缓存待写入的数据，并且最多缓存最近 1 分钟的数据。当客户端发现分片转移操作执行完时，客户端会立即掏空缓存，将数据写入到节点中。如果分片转移速度太慢，读请求可以被手动或自动地转发到另一个区域。</p>
<p>当新的分片被分配给一个节点时，该节点需要从 GlusterFS 中读入所有数据。通常加载和预处理这些数据需要 5 分钟。当该节点正在恢复数据时，新写入的时序样本数据会被放入一个待处理队列。在老节点发生故障后，新节点加载分片数据完毕之前，读请求可能会读到部分数据，并打上标记。如果客户端发现数据被标记为部分数据，会再次请求另一个区域中的数据，如果数据完整则返回后者，失败则返回两组部分数据。</p>
<p>最后，FB 仍然使用 HBase TSDB 来存储长期数据，工程师仍然可以通过它来分析过去的时序数据。</p>
<h1 id="new-tools-on-gorilla">New Tools on Gorilla</h1>
<p>由于 Gorilla 的数据存放在内存中，这样让更多的实时分析成为可能。</p>
<ul>
<li>相关性分析引擎，主要用于快速发现相关性很高的时序数据，从而辅助根源分析</li>
<li>监控绘图</li>
<li>聚合分析</li>
</ul>
<h1 id="experience">Experience</h1>
<h2 id="lesson-learned">Lesson Learned</h2>
<ul>
<li><p>Prioritize recent data over historical data</p></li>
<li><p>Read latency matters</p></li>
<li><p>High availability trumps resource efficiency</p></li>
</ul>
<h1 id="references">References</h1>
<p><a href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf" target="_blank" rel="noopener">gorilla paper</a></p>
<svg style="display: none" id="MJX-SVG-global-cache"><defs><path id="MJX-TEX-I-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-TEX-I-44" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path><path id="MJX-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-TEX-I-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs></svg>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhengHe"
      src="/blog/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ZhengHe</p>
  <div class="site-description" itemprop="description">郑鹤的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhengHe-MD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhengHe-MD" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ranchardzheng@gmail.com" title="E-Mail → mailto:ranchardzheng@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhengHe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zhenghe-hexo-blog.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
